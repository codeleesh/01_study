# 연관관계 메소드 정리

- 다대다 관계는 사용하면 안된다.

  - 일대다, 다대일 관계로 풀어내야 한다.

- 가급적이면 양방향 연관관계는 사용하지 말고 단방향 연관관계를 사용해야 한다.

  - 회원과 주문의 관계
  - 회원이 주문을 하니 회원의 주문 목록을 가지고 있으면 되겠다?
  - 회원을 통해서 주문이 생성되는 것이 아니라 주문을 생성할 때 회원이 필요하다라고 생각하는 것이 맞다.
  - 쿼리로 볼때, 주문에서 필터링으로 회원 정보가 들어간다.

- `@OneToMany`

  - 거울
  - 연관관계 주인 엔티티의 선언된 해당 엔티티의 변수명입니다.
  - 읽기 전용이며, FK의 값이 변경되지 않습니다.

- `@ManyToOne`

  - 연관관계 주인
  - 연관관계 주인을 설정할 때, FK가 가까운 곳을 연관관계 주인으로 매핑합니다.
  - 예를 들어,
    - 현재 주문 테이블의 member_id의 FK가 존재합니다.
    - 그래서 이것을 연관관계 주인으로 매핑을 하면 됩니다.
    - 생각해보면 멤버 테이블에서 멤버를 변경하였는데, 멤버의 연관관계인 주문이 같이 변경된다면 이상하지 않을까요?
    - 그러면 주문의 멤버가 변경된다면, 내 테이블의 컬럼을 변경한거니깐 머릿속으로 쉽게 흘러갑니다.

- `@OneToOne`

  - JPA에서는 1:1 관계에서는 FK를 양쪽 어느 곳에 생성을 해도 됩니다.
  - 주로 접근을 많이 하는 곳에서 FK를 생성하는 것이 좋습니다.
  - 예를 들어,
    - 주문에 생성해도 되고 배송에 생성해도 됩니다.
    - 배송을 직접 조회하는 것보다는 주문을 통해서 배송 정보를 같이 보는 것이 많다면 주문의 FK를 생성하는 것이 괜찮아 보입니다.
    - 주문의 FK가 가까우니 연관관계 주인으로 설정하면 됩니다.

- `@ManyToMany`

  - 실무에서는 거의 사용하지 않습니다.
  - 다대일, 일대다로 풀어서 사용해야 합니다.
  - 만약 사용을 해야한다면 제약 조건이 있습니다.
  - 필드 추가가 어렵습니다.
  - 중간 테이블 연결을 위해서 JoinTable을 사용해야 하며, `joinColumns`, `inverseJoinColumns`을 정의해서 사용하면 중간 테이블이 생성됩니다.
  - 절대 사용하면 안됩니다.
    - `@ManyToMany`는 편리한 것 같지만, 중간 테이블에 컬럼을 추가할 수 없습니다.
    - 세밀하게 쿼리를 실행하기 어렵기 때문에 실무에서 사용하기에는 한계가 있습니다.
    - 중간 엔티티를 만들고 `@ManyToOne`, `@OneToMany`로 매핑해서 사용해야 합니다.
    - 다대다 매핑으로 풀어내서 사용해야 합니다.

- 본인 계층 구조 만들기

  - 상점 테이블이 있다고 가정합시다.

  - 상점 테이블의 변수를 `parent`로 정하고 연관관계 주인을 설정합니다.

  - 상점 테이블을 List를 이용하여 `child`로 정하고 거울로 정합니다.

    ```
    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Book parent;
    
    @OneToMany(mappedBy = "parent")
    private List<Book> child = new ArrayList<>();
    ```

### 모든 연관관계는 지연로딩으로 설정!

- 즉시로딩(`EAGER`)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵습니다.
- 특히 JPQL을 실행할 때 N+1 문제가 자주 발생합니다.
- 실무에서 모든 연관관계는 지연로딩(`LAZY`)으로 설정해야 합니다.
- 한번에 쿼리로 가져와야될 경우 `fetch`, `EntityGraph`를 활용할 수 있습니다.
- ToOne의 기본 전략은 EAGER
- ToMany의 기본 전략은 LAZY